软件缺陷 (Software Defect45) : 存在于软件（文档、数据、程序）之中的那些不希望或不可接受的偏差。缺陷事实上是一个静态的事物。那么，在我们使用手机时出现的“闪退”或者“打怪”时游戏崩溃是缺陷吗？不是！这些都不是缺陷，而是缺陷被激活时表现出的外部行为结果。这些恼人的外部行为结果在标准的软件测试术语中被称为失效。软件失效(Software Failure): 软件运行时产生的一种不希望或不可接受的外部行为结果（可以通过运行结果被观测到）软件故障(Software Fault): 软件运行过程中出现的一种不希望或不可接受的内部状态（不能通过运行结果被观测到）。故障是缺陷激活的结果，或者换句话说，缺陷只存在于程序或软件工件里，是一个静态的事物，当程序运行时，程序不再被称为程序而是进程，相应地，缺陷不再是缺陷而被称为故障（如果缺陷被激活的话，即进程运行到包含缺陷的代码并且产生了与预期不相符的行为）。如果缺陷被激活，软件内部就可能会出现故障，对于软件故障如果没有适当的处理措施的话，很可能会导致软件失效。外部可见的软件失效是测试中推断软件中存在缺陷的基本方法。没有失效并不代表软件中不存在缺陷Software Fault (软件故障)，有缺陷并不一定产生故障，，有故障也并不一定会失效，产生失效一定意味着软件有故障，产生失效一定意味着软件存在缺陷，产生故障一定意味着软件存在缺陷，有缺陷并不一定产生故障，有故障也并不一定会失效。缺陷具有隐蔽性，需要使用专门的方法和技术予以捕捉，而承担这个任务的角色就是测试工程师。测试人员的任务就是千方百计地在庞大的输入域中找到那些能够将缺陷暴露出来的输入，而且越早越好。 
请记住缺陷的暴露需要满足三个条件：可达性(Reachability)、感染性(Infection)和传播性(Propagation)，这三个条件集合在一起被称为 RIP 模型。1) Reachability: The location or locations in the program that contain the defectmust be reached2) Infection: After executing the location, the state of the program must be incorrect （请注意：感染性是指在执行包含缺陷的代码后，系统的实际状态和期望的不一致）。3) Propagation: The infected state must propagate to cause some output of the program to be incorrect.以 findLast为例深入讲解缺陷、故障、失效和 RIP 模型1) 案例中已给的输入：x={2,3,5}; y=2，由于期望输出11是 0，而实际输出12是-1，因此，使用 x={2,3,5}; y=2 可能捕捉到该缺陷；然而，不是任何输入都能做到这点2) 不能执行到包含缺陷的代码： 如果选择 x=Null，y=任意值，例如,(x=null,y=4)的输入运行代码的话，则并没有执行到包含缺陷的位置，程序运行就已经结束了。此时，我们称输入（实际上应该说测试输入）不具可达性。3) 具备可达性的输入不一定能产生故障(没有故障自然不会有失效)，例如输入x={ }（空数组），y=4，在正确和错误代码下运行的内部状态都一样。因为 i=-1，在执行完成错误代码 i>0 和正确代码 i>=0 的情况下，PC 指针都是 return -1 且各个变量的值也都相同：x 为空数组，y=4，i=-1。不能产生故障的输入不具感染性。感染性的判断是在执行完成包含缺陷代码之后即刻进行的，对于 findLast是在执行 i>0 之后马上判断，例如对于 x=[1,2,4]，y=4，因为正确（绿色）和错误（橘色）代码下运行后的系统的状态是一样的，因此，并没有产生故障。4）具备可达性和感染性的输入不一定产生失效（毕竟只有产生失效，才会知道代码中有缺陷），例如 x=[1]，y=4，在正确和错误代码下运行的最终结果都一样，虽然在执行过程中存在故障，但错误的内部状态并没有被传播到最终可观测的输出结果。虽然在执行过程中存在若干故障（Figure 1-7 中的橘色状态都是，绿色状态是期望的正确状态），但错误的内部状态并没有被传播到最终可观测的输出结果，最终结果都是 return -1。不能将故障状态保持到可观测端的输入不具传播性。
什么是软件质量，缺陷是相对于软件质量而言的，如果对质量没有要求，则缺陷就失去了讨论的价值和基础。那么，什么是软件质量呢？著名的质量管理专家 Joseph M Juran给出的质量定义为：质量是一种适用性，即产品在使用期间能满足使用者的需求。在 Juran 定义的基础上，IEEE Standard 829-2008 定义质量是系统、组件或过程满足特定需求的程度，满足客户/用户需求或期望的程度。1) 功能性（Functionality）：软件所实现的功能达到其设计规范和满足用户需求的程度2) 可靠性（Reliability）：在规定的时间和条件下，软件能维持其正常的功能操作、性能水平的程度/概率3) 易用性（Usability）：用户，包括正常人和残疾人，学习、操作、准备输入和理解输出所作努力的程度4) 效率（Efficiency）：在指定条件下，软件对操作的响应速度以及实现某种功能能有效利用计算资源的程度5) 可维护性（Maintainability）：当软件投入应用后，当需求发生变化，环境改变或软件发生错误时，进行修改的难易程度6) 可移植性（Portability）：软件从一个计算机系统或环境移植到另一个计算机系统或环境的容易程度，或者一个系统和外部条件共同工作的容易程度
ISO/IEC 25010 是目前为止最新的质量属性模型1) 功能性（Functionality）：软件所实现的功能达到其设计规范和满足用户需求的程度2) 可靠性（Reliability）：在规定的时间和条件下，软件能维持其正常的功能操作、性能水平的程度/概率3) 易用性（Usability）：用户，包括正常人和残疾人，学习、操作、准备输入和理解输出所作努力的程度4) 效率（Efficiency）：在指定条件下，软件对操作的响应速度以及实现某种功能能有效利用计算资源的程度5) 可维护性（Maintainability）：当软件投入应用后，当需求发生变化，环境改变或软件发生错误时，进行修改的难易程度6) 可移植性（Portability）：软件从一个计算机系统或环境移植到另一个计算机系统或环境的容易程度，或者一个系统和外部条件共同工作的容易程度
软件测试是贯穿整个软件开发生命周期，对软件产品进行验证和确认的活动过程，也是对软件产品质量持续的评估过程，其目的是尽快尽早地发现软件产品中存在的各种缺陷，尽最大可能揭示软件开发过程中所存在的产品质量风险。软件测试包含静态测试和动态测试两个部分，值得说明地是，在本课程中我们主要关注动态测试，讨论动态测试方法。不同的软件组织会根据产品特性、开发过程、组织结构等采用不同的测试过程，但都遵守“被测对象粒度从小到大推进”的原则。比较常见的一种测试过程是按照“代码单元测试→代码接口测试→系统功能测试→系统非功能测试→成品测试”的路线推进。
软件测试的挑战来源于在现实的条件下无法穷举输入组合空间中的每一元素，在实际的测试活动中，只能从中挑选出一些作代表，在软件测试领域通常称这些代表为测试用例（Test Case）。测试用例（集合）（Test Set）是针对被测对象运用软件测试方法技术的可视化结果，是软件测试中用于揭示缺陷验证行为的依据。测试用例的质量体现了测试人员能力的高低，决定着测试的质量。软件测试国际标准 ISO/IEC/IEEE 2911930给出了测试用例31的定义，但是，测试用例的具体定义还是众说纷纭并不统一。不过，一般都遵循包含测试前准备、测试中和测试后验证的测试用例结构原则。在我看到的所有关于测试用例的定义中，Paul Amman 等32给出的定义全面不失一般性：A test case is composed of the test case values, expected result, prefix values, postfixvalues for a complete execution and evaluation of the software under test：1) Test Case Values: The input values necessary to complete some execution ofthe software under test.2) Expected Results: The result that will be produced when executing the test if theprogram satisfies it intended behavior3) Prefix Values: Any inputs necessary to put the software into the appropriate stateto receive the test case values4) Postfix Values: Any inputs that need to be sent to the software after the test casevalues. There are usually two types of postfix values:i.Verification Values: Values necessary to see the results of the test case valuesii.Values needed to terminate the program or otherwise return it to a stable state
测试用例的实现形式、结构和标准会随测试活动、软件组织的不同而有区别，但是有一点非常重要就是测试用例里必须包括测试输入值和相应的预期结果，尤其是预期结果。一个高质量的测试用例应该具备四个属性：有效性、仿效性、经济性和可维护性。有效性是指测试用例是否能够发现缺陷或者至少可能发现缺陷。软件测试的主要目的是寻找缺陷，因此，能够发现缺陷的测试用例比不能够发现缺陷的测试用例质量要高。仿效性用来衡量测试用例的代表程度。通常情况下，可能输入的输入项组合数目非常庞大，在现实条件下，软件测试人员们不可能在测试用例集合中穷举所有的输入组合，在测试时，只能选择其中的一些做代表。当然，这种挑选并不是随意的，需要符合这些被选出的测试用例如果不能发现缺陷，那么，没有被选出的测试用例能够发现同类型缺陷的概率应该非常低的原则。被选中的测试用例代表的测试用例数越多，则说明该测试用例的仿效性越好。经济性用来衡量测试用例所花费的成本，包括设计、实现、调试和运行测试用例的成本。可维护性是指修改和维护测试用例的难易程度。一个好的测试用例应该可以随着软件的不断变更，稍加变动甚至不作任何变动便可以多次重用以此降低重复测试的成本。由测试用例构成的集合被称为测试集合。